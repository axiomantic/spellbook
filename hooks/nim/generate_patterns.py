#!/usr/bin/env python3
"""Generate Nim source from Python security rules.

Reads spellbook_mcp/security/rules.py, extracts all pattern definitions,
and produces hooks/nim/src/generated_patterns.nim with:
  - All regex patterns as Nim string constants
  - Severity levels and category classifications
  - Mode threshold mappings
  - SHA1 hash of rules.py for runtime staleness detection
  - Pre-compiled regex objects at module init time
  - Pattern checking procs for each hook type
"""

import hashlib
import sys
from datetime import datetime, timezone
from pathlib import Path

# Add project root to path so we can import rules
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from spellbook_mcp.security.rules import (
    ESCALATION_RULES,
    EXFILTRATION_RULES,
    INJECTION_RULES,
    OBFUSCATION_RULES,
    Severity,
    _DANGEROUS_BASH_EXTRA,
    _MODE_SEVERITY_THRESHOLD,
)


def escape_for_nim(pattern: str) -> str:
    """Escape a regex pattern for use in a Nim raw string literal.

    Nim raw strings (r"...") only need " escaped as "".
    """
    return pattern.replace('"', '""')


def severity_to_nim(sev: Severity) -> str:
    """Convert Python Severity enum to Nim enum name."""
    return {
        Severity.LOW: "svLow",
        Severity.MEDIUM: "svMedium",
        Severity.HIGH: "svHigh",
        Severity.CRITICAL: "svCritical",
    }[sev]


def generate_pattern_array(name: str, rules: list) -> str:
    """Generate a Nim seq of PatternRule from a Python rule list."""
    lines = [f"let {name}*: seq[PatternRule] = @["]
    for pattern, severity, rule_id, message in rules:
        nim_pattern = escape_for_nim(pattern)
        nim_sev = severity_to_nim(severity)
        # Escape message for Nim string
        nim_message = message.replace('"', '\\"')
        nim_rule_id = rule_id.replace('"', '\\"')
        lines.append(f'  PatternRule(')
        lines.append(f'    pattern: r"{nim_pattern}",')
        lines.append(f'    severity: {nim_sev},')
        lines.append(f'    ruleId: "{nim_rule_id}",')
        lines.append(f'    message: "{nim_message}",')
        lines.append(f'    compiled: re(r"{nim_pattern}"),')
        lines.append(f'  ),')
    lines.append("]")
    return "\n".join(lines)


def main():
    # Compute hash of rules.py
    rules_path = project_root / "spellbook_mcp" / "security" / "rules.py"
    rules_content = rules_path.read_text()
    rules_hash = "sha1:" + hashlib.sha1(rules_content.encode()).hexdigest()

    # Generate output
    output_path = Path(__file__).parent / "src" / "generated_patterns.nim"

    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

    lines = []
    lines.append("# generated_patterns.nim")
    lines.append("# AUTO-GENERATED by generate_patterns.py - DO NOT EDIT")
    lines.append(f"# Source: spellbook_mcp/security/rules.py")
    lines.append(f"# Generated: {timestamp}")
    lines.append("")
    lines.append("import std/re")
    lines.append("")
    lines.append(f'const RULES_PY_HASH* = "{rules_hash}"')
    lines.append("")

    # Type definitions
    lines.append("type")
    lines.append("  Severity* = enum")
    lines.append("    svLow = 1")
    lines.append("    svMedium = 2")
    lines.append("    svHigh = 3")
    lines.append("    svCritical = 4")
    lines.append("")
    lines.append("  PatternRule* = object")
    lines.append("    pattern*: string")
    lines.append("    severity*: Severity")
    lines.append("    ruleId*: string")
    lines.append("    message*: string")
    lines.append("    compiled*: Regex  ## Pre-compiled at module init time")
    lines.append("")
    lines.append("  Finding* = object")
    lines.append("    ruleId*: string")
    lines.append("    severity*: string")
    lines.append("    message*: string")
    lines.append("    matchedText*: string")
    lines.append("")

    # Mode thresholds
    lines.append("# Mode thresholds: minimum severity to report")
    lines.append(
        "const MODE_THRESHOLDS*: array[3, tuple[mode: string, threshold: Severity]] = ["
    )
    for mode, threshold in _MODE_SEVERITY_THRESHOLD.items():
        nim_threshold = severity_to_nim(threshold)
        lines.append(f'  ("{mode}", {nim_threshold}),')
    lines.append("]")
    lines.append("")

    # Pattern arrays (with pre-compiled Regex in each PatternRule)
    lines.append("# --- Pattern Arrays (regexes pre-compiled at module init) ---")
    lines.append("")
    lines.append(generate_pattern_array("INJECTION_PATTERNS", INJECTION_RULES))
    lines.append("")
    lines.append(generate_pattern_array("EXFILTRATION_PATTERNS", EXFILTRATION_RULES))
    lines.append("")
    lines.append(generate_pattern_array("ESCALATION_PATTERNS", ESCALATION_RULES))
    lines.append("")
    lines.append(
        generate_pattern_array("DANGEROUS_BASH_EXTRA", _DANGEROUS_BASH_EXTRA)
    )
    lines.append("")
    lines.append(generate_pattern_array("OBFUSCATION_PATTERNS", OBFUSCATION_RULES))
    lines.append("")

    # Composite pattern sets
    lines.append("# --- Composite Pattern Sets (matching check.py routing) ---")
    lines.append("")
    lines.append("let BASH_CHECK_PATTERNS*: seq[PatternRule] =")
    lines.append(
        "  ESCALATION_PATTERNS & DANGEROUS_BASH_EXTRA & EXFILTRATION_PATTERNS"
    )
    lines.append("")
    lines.append("let SPAWN_CHECK_PATTERNS*: seq[PatternRule] =")
    lines.append("  INJECTION_PATTERNS & ESCALATION_PATTERNS")
    lines.append("")
    lines.append("let STATE_CHECK_PATTERNS*: seq[PatternRule] =")
    lines.append("  INJECTION_PATTERNS")
    lines.append("")

    # Check procedure (uses pre-compiled regex from PatternRule.compiled)
    lines.append("# --- Check Procedures ---")
    lines.append("")
    lines.append("proc checkPatterns*(")
    lines.append("  text: string,")
    lines.append("  patterns: seq[PatternRule],")
    lines.append('  securityMode: string = "standard"')
    lines.append("): seq[Finding] =")
    lines.append("  var threshold = svHigh  # default")
    lines.append("  for mt in MODE_THRESHOLDS:")
    lines.append("    if mt.mode == securityMode:")
    lines.append("      threshold = mt.threshold")
    lines.append("      break")
    lines.append("")
    lines.append("  for rule in patterns:")
    lines.append("    if rule.severity.ord < threshold.ord:")
    lines.append("      continue")
    lines.append("    # Use pre-compiled regex from PatternRule.compiled")
    lines.append("    let bounds = text.findBounds(rule.compiled)")
    lines.append("    if bounds.first >= 0:")
    lines.append("      result.add(Finding(")
    lines.append("        ruleId: rule.ruleId,")
    lines.append("        severity: $rule.severity,")
    lines.append("        message: rule.message,")
    lines.append("        matchedText: text[bounds.first..bounds.last],")
    lines.append("      ))")
    lines.append("")

    output_path.write_text("\n".join(lines) + "\n")
    print(f"Generated {output_path} with hash {rules_hash}")
    print(f"  INJECTION_PATTERNS: {len(INJECTION_RULES)} rules")
    print(f"  EXFILTRATION_PATTERNS: {len(EXFILTRATION_RULES)} rules")
    print(f"  ESCALATION_PATTERNS: {len(ESCALATION_RULES)} rules")
    print(f"  DANGEROUS_BASH_EXTRA: {len(_DANGEROUS_BASH_EXTRA)} rules")
    print(f"  OBFUSCATION_PATTERNS: {len(OBFUSCATION_RULES)} rules")
    print(f"  NOTE: All regexes pre-compiled at module init time")


if __name__ == "__main__":
    main()
