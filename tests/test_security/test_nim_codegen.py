"""Tests for the security pattern codegen pipeline.

Validates that generate_patterns.py correctly translates Python security
rules into Nim source code with:
  - All rule IDs present
  - Correct SHA1 hash of rules.py
  - Composite pattern sets for each hook type
  - Pre-compiled Regex fields in PatternRule instances
"""

import hashlib
import re
import subprocess
import sys
from pathlib import Path

import pytest

PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent


class TestGeneratePatterns:
    """Test that generate_patterns.py produces correct Nim source."""

    def _run_codegen(self):
        """Run the codegen script and return the subprocess result."""
        result = subprocess.run(
            [sys.executable, str(PROJECT_ROOT / "hooks" / "nim" / "generate_patterns.py")],
            capture_output=True,
            text=True,
            timeout=30,
            cwd=str(PROJECT_ROOT),
        )
        return result

    def _read_generated(self):
        """Run codegen and return the generated Nim source text."""
        result = self._run_codegen()
        assert result.returncode == 0, f"codegen failed: {result.stderr}"
        gen_path = PROJECT_ROOT / "hooks" / "nim" / "src" / "generated_patterns.nim"
        assert gen_path.exists(), "generated_patterns.nim not created"
        return gen_path.read_text()

    def test_codegen_runs_successfully(self):
        """generate_patterns.py should exit 0."""
        result = self._run_codegen()
        assert result.returncode == 0, f"codegen failed: {result.stderr}"

    def test_generated_file_exists(self):
        """generated_patterns.nim should exist after codegen."""
        self._run_codegen()
        gen_path = PROJECT_ROOT / "hooks" / "nim" / "src" / "generated_patterns.nim"
        assert gen_path.exists(), "generated_patterns.nim not created"

    def test_all_rule_ids_present(self):
        """All rule IDs from rules.py should appear in generated Nim source."""
        nim_source = self._read_generated()

        from spellbook_mcp.security.rules import (
            ESCALATION_RULES,
            EXFILTRATION_RULES,
            INJECTION_RULES,
            OBFUSCATION_RULES,
            _DANGEROUS_BASH_EXTRA,
        )

        all_rules = [
            ("INJECTION", INJECTION_RULES),
            ("EXFILTRATION", EXFILTRATION_RULES),
            ("ESCALATION", ESCALATION_RULES),
            ("DANGEROUS_BASH_EXTRA", _DANGEROUS_BASH_EXTRA),
            ("OBFUSCATION", OBFUSCATION_RULES),
        ]
        for rule_set_name, rules in all_rules:
            for _pattern, _severity, rule_id, _message in rules:
                assert rule_id in nim_source, (
                    f"Rule {rule_id} from {rule_set_name} not found in generated_patterns.nim"
                )

    def test_hash_matches_current_rules(self):
        """The embedded hash should match the current rules.py content."""
        nim_source = self._read_generated()

        rules_path = PROJECT_ROOT / "spellbook_mcp" / "security" / "rules.py"
        rules_content = rules_path.read_text()
        expected_hash = "sha1:" + hashlib.sha1(rules_content.encode()).hexdigest()

        match = re.search(r'RULES_PY_HASH\* = "([^"]+)"', nim_source)
        assert match, "RULES_PY_HASH not found in generated_patterns.nim"
        assert match.group(1) == expected_hash, (
            f"Hash mismatch: expected {expected_hash}, got {match.group(1)}"
        )

    def test_composite_sets_defined(self):
        """Composite pattern sets should be defined for each hook type."""
        nim_source = self._read_generated()

        assert "BASH_CHECK_PATTERNS" in nim_source
        assert "SPAWN_CHECK_PATTERNS" in nim_source
        assert "STATE_CHECK_PATTERNS" in nim_source

    def test_precompiled_regex_in_pattern_rules(self):
        """Each PatternRule should include a compiled Regex field."""
        nim_source = self._read_generated()

        # PatternRule type should have a compiled field
        assert "compiled*: Regex" in nim_source, "PatternRule missing compiled Regex field"
        # Each rule instance should have compiled: re(...)
        compiled_count = nim_source.count("compiled: re(")
        # Count actual rule instances (ruleId: "...") not references like ruleId: rule.ruleId
        rule_count = nim_source.count('ruleId: "')
        assert compiled_count == rule_count, (
            f"Expected {rule_count} compiled regex entries, got {compiled_count}"
        )

    def test_generated_file_has_auto_generated_header(self):
        """Generated file should have the AUTO-GENERATED warning header."""
        nim_source = self._read_generated()

        assert "AUTO-GENERATED by generate_patterns.py" in nim_source
        assert "DO NOT EDIT" in nim_source

    def test_severity_enum_defined(self):
        """Severity enum should be defined with correct values."""
        nim_source = self._read_generated()

        assert "svLow = 1" in nim_source
        assert "svMedium = 2" in nim_source
        assert "svHigh = 3" in nim_source
        assert "svCritical = 4" in nim_source

    def test_mode_thresholds_defined(self):
        """Mode thresholds should map security modes to severity levels."""
        nim_source = self._read_generated()

        assert "MODE_THRESHOLDS" in nim_source
        assert '"standard"' in nim_source
        assert '"paranoid"' in nim_source
        assert '"permissive"' in nim_source

    def test_check_patterns_proc_defined(self):
        """checkPatterns proc should be defined for pattern matching."""
        nim_source = self._read_generated()

        assert "proc checkPatterns*(" in nim_source

    def test_codegen_stdout_reports_counts(self):
        """Codegen should report rule counts on stdout."""
        result = self._run_codegen()
        assert result.returncode == 0

        assert "INJECTION_PATTERNS:" in result.stdout
        assert "EXFILTRATION_PATTERNS:" in result.stdout
        assert "ESCALATION_PATTERNS:" in result.stdout
        assert "DANGEROUS_BASH_EXTRA:" in result.stdout
        assert "OBFUSCATION_PATTERNS:" in result.stdout

    def test_codegen_is_idempotent(self):
        """Running codegen twice should produce identical output."""
        self._run_codegen()
        gen_path = PROJECT_ROOT / "hooks" / "nim" / "src" / "generated_patterns.nim"
        first_content = gen_path.read_text()

        # Strip the timestamp line since it changes each run
        first_lines = [
            line for line in first_content.splitlines()
            if not line.startswith("# Generated:")
        ]

        self._run_codegen()
        second_content = gen_path.read_text()
        second_lines = [
            line for line in second_content.splitlines()
            if not line.startswith("# Generated:")
        ]

        assert first_lines == second_lines, "Codegen is not idempotent"
